import type { Dependency } from "@/entities/dependency/model/types";
import type {
    Vulnerability,
    PackageVulnerability,
    VulnerabilityAnalysisResult,
    SeverityWithSafe,
    Severity,
} from "@/entities/vulnerability/model/types";
import { queryOSVBatch } from "@/shared/api/osv-client";
import { osvSeverityToSeverity, type OSVVulnerability } from "@/features/vulnerability-analyzer/model/schemas";

/**
 * 심각도 우선순위 (높을수록 심각)
 */
const SEVERITY_PRIORITY: Record<SeverityWithSafe, number> = {
  critical: 4,
  high: 3,
  medium: 2,
  low: 1,
  safe: 0,
};

/**
 * 두 심각도 중 더 높은 것을 반환
 */
function maxSeverity(a: SeverityWithSafe, b: SeverityWithSafe): SeverityWithSafe {
  return SEVERITY_PRIORITY[a] >= SEVERITY_PRIORITY[b] ? a : b;
}

/**
 * OSV 취약점을 내부 Vulnerability 형식으로 변환
 */
function mapOSVToVulnerability(osv: OSVVulnerability, packageName: string): Vulnerability {
  // CVSS 점수 추출
  let severity: Severity = "medium";
  if (osv.severity && osv.severity.length > 0) {
    const cvss = osv.severity.find((s) => s.type === "CVSS_V3" || s.type === "CVSS_V2");
    if (cvss?.score) {
      severity = osvSeverityToSeverity(cvss.score);
    }
  }

  // 영향받는 버전 범위 추출
  let affectedVersions = "unknown";
  let fixedVersion: string | undefined;
  
  const affected = osv.affected?.find((a) => a.package.name === packageName);
  if (affected) {
    if (affected.versions && affected.versions.length > 0) {
      affectedVersions = affected.versions.join(", ");
    } else if (affected.ranges && affected.ranges.length > 0) {
      const range = affected.ranges[0];
      const introduced = range.events.find((e) => e.introduced)?.introduced;
      const fixed = range.events.find((e) => e.fixed)?.fixed;
      
      if (introduced && fixed) {
        affectedVersions = `${introduced} - ${fixed}`;
        fixedVersion = fixed;
      } else if (introduced) {
        affectedVersions = `>=${introduced}`;
      }
    }
  }

  // 참조 URL
  const referenceUrl = osv.references?.find((r) => r.type === "ADVISORY")?.url
    || osv.references?.[0]?.url;

  return {
    id: osv.id,
    severity,
    title: osv.summary || osv.id,
    description: osv.details,
    affectedVersions,
    fixedVersion,
    referenceUrl,
  };
}

/**
 * 테스트용 심각도 순환 배열
 */
const TEST_SEVERITIES: Severity[] = ["critical", "high", "medium", "low"];

/**
 * 의존성 목록의 취약점을 분석합니다.
 * @param testMode - true면 각 패키지에 순환하는 심각도 할당 (개발 테스트용)
 */
export async function analyzeVulnerabilities(
  dependencies: Dependency[],
  testMode: boolean = false
): Promise<VulnerabilityAnalysisResult> {
  // 테스트 모드: 실제 API 호출 없이 모의 데이터 생성
  if (testMode) {
    return generateTestData(dependencies);
  }

  // OSV API 일괄 조회
  const packagesForQuery = dependencies.map((dep) => ({
    name: dep.name,
    version: dep.version,
  }));

  const osvResults = await queryOSVBatch(packagesForQuery);

  // 결과 변환
  const packages: PackageVulnerability[] = [];
  const summary = { critical: 0, high: 0, medium: 0, low: 0, safe: 0 };
  let totalVulnerabilities = 0;

  for (const dep of dependencies) {
    const key = `${dep.name}@${dep.version}`;
    const osvResponse = osvResults.get(key);

    const vulnerabilities: Vulnerability[] = [];
    let pkgMaxSeverity: SeverityWithSafe = "safe";

    if (osvResponse?.vulns && osvResponse.vulns.length > 0) {
      for (const osv of osvResponse.vulns) {
        const vuln = mapOSVToVulnerability(osv, dep.name);
        vulnerabilities.push(vuln);
        pkgMaxSeverity = maxSeverity(pkgMaxSeverity, vuln.severity);
      }
      totalVulnerabilities += vulnerabilities.length;
    }

    packages.push({
      packageName: dep.name,
      version: dep.version,
      vulnerabilities,
      maxSeverity: pkgMaxSeverity,
    });

    summary[pkgMaxSeverity]++;
  }

  return {
    packages,
    summary,
    totalVulnerabilities,
  };
}

/**
 * 테스트 모드용 모의 데이터 생성
 * 각 패키지에 critical → high → medium → low 순서로 심각도 할당
 */
function generateTestData(dependencies: Dependency[]): VulnerabilityAnalysisResult {
  const packages: PackageVulnerability[] = [];
  const summary = { critical: 0, high: 0, medium: 0, low: 0, safe: 0 };
  let totalVulnerabilities = 0;

  for (let i = 0; i < dependencies.length; i++) {
    const dep = dependencies[i];
    const severity = TEST_SEVERITIES[i % TEST_SEVERITIES.length];
    
    const mockVuln: Vulnerability = {
      id: `TEST-${i + 1}`,
      severity,
      title: `[테스트] ${severity.toUpperCase()} 취약점`,
      description: `이것은 ${severity} 심각도를 테스트하기 위한 모의 취약점입니다.`,
      affectedVersions: dep.version,
    };

    packages.push({
      packageName: dep.name,
      version: dep.version,
      vulnerabilities: [mockVuln],
      maxSeverity: severity,
    });

    summary[severity]++;
    totalVulnerabilities++;
  }

  return {
    packages,
    summary,
    totalVulnerabilities,
  };
}
