"use server";

import type { ParsedPackage } from "@/entities/dependency/model/types";
import type { VulnerabilityAnalysisResult } from "@/entities/vulnerability/model/types";
import { analyzeVulnerabilities } from "@/features/vulnerability-analyzer/lib/analyze-vulnerabilities";

export type AnalyzeResult =
  | { success: true; data: VulnerabilityAnalysisResult }
  | { success: false; error: string };

/**
 * 파싱된 패키지의 취약점을 분석합니다.
 * @param testMode - true면 모의 데이터로 테스트 (개발용)
 */
export async function analyzePackageVulnerabilities(
  parsedPackage: ParsedPackage,
  testMode: boolean = false
): Promise<AnalyzeResult> {
  try {
    if (parsedPackage.dependencies.length === 0) {
      return {
        success: true,
        data: {
          packages: [],
          summary: { critical: 0, high: 0, medium: 0, low: 0, safe: 0 },
          totalVulnerabilities: 0,
        },
      };
    }

    const result = await analyzeVulnerabilities(parsedPackage.dependencies, testMode);

    return {
      success: true,
      data: result,
    };
  } catch (error) {
    console.error("취약점 분석 실패:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "취약점 분석 중 오류가 발생했습니다.",
    };
  }
}

